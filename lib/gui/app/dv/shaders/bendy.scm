
(define-instance-variable *start* (0 100) <point>)
(define-instance-variable *end* (100 0) <point>)
(define-instance-variable *h-first?* #t <boolean>)
(define-instance-variable *interior* (33pt 66pt) (list <number:length>))
(define-instance-variable *radius* 0pt <number:length>)
(define-instance-variable *end-arrow* #t <boolean>)
(define-instance-variable *arrow-length-ratio* 6 <number>)
(define-instance-variable *arrow-width-ratio* 2 <number>)
(define-instance-variable *style* (black 0.5pt) <stroke-style>)

(define-procedure (next p x1 y1 h?)
  (if h?
      (make-point x1 (y p))
      (make-point (x p) y1)))

(define-procedure (mkpath art?)
  (moveto *start*)
  (let loop ((i *interior*)
             (p *start*)
             (h? *h-first?*))
    (if (null? i)
        (let ((ntl (next p (x *end*) (y *end*) h?)))
          (lineto ntl)
          (lineto *end*)
          ntl)
        (let ((n (next p (car i) (car i) h?)))
          (lineto n)
          (loop (cdr i) n (not h?))))))

(define-procedure (outline)
  (mkpath #t)
  (stroke))

(define-procedure (draw)
  (let ((prev (mkpath #f)))
    (stroke *style*)
    (if *end-arrow*
        (let ((w (lay-flat prev *end*))
              (x1 (* *arrow-length-ratio* (style-stroke-width *style*) -1))
              (y1 (* *arrow-width-ratio* (style-stroke-width *style*))))
          (translate w 0)
          (moveto 0 0)
          (lineto x1 y1)
          (lineto x1 (- y1))
          (closepath)
          (fill *style*)))))

(define-procedure (artwork)
  (mkpath #t)
  (stroke))

(define-procedure (handles)
  (handle *start*)
  (handle *end*)
  (let loop ((i *interior*)
             (p *start*)
             (h? *h-first?*)
             (v #f))
    (if (null? i)
        (let ((n (next p (x *end*) (y *end*) h?)))
          (if v
              (handle (point-average p n))))
        (let ((n (next p (car i) (car i) h?)))
          (if v
              (handle (point-average p n)))
          (loop (cdr i) n (not h?) #t)))))

(define-procedure (tweak h x0 y0)
  (case h
    ((0) (lambda (x y) (set! *start* (make-point x y)) (values 0 0)))
    ((1) (lambda (x y) (set! *end* (make-point x y)) (values 0 0)))
    (else
     (let ((cell (list-tail *interior* (- h 2))))
       (if (= (modulo (if *h-first?* h (+ h 1)) 2) 0)
           (lambda (x y) (set-car! cell x) (values 0 0))
           (lambda (x y) (set-car! cell y) (values 0 0)))))))

(define-interactive (flip)
  (interactive)
  (set! *h-first?* (not *h-first?*))
  (let loop ((i *interior*)
             (p *start*)
             (h? *h-first?*)
             (v #f)
             (r '()))
    (if (null? i)
        (let ((n (next p (x *end*) (y *end*) h?)))
          (if v
              (handle (point-average p n))))
        (let ((n (next p (car i) (car i) h?)))
          (if v
              (handle (point-average p n)))
          (loop (cdr i) n (not h?) #t)))))
